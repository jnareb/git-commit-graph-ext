<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.357">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Describe different types of reachability indices (labels), define negative-cut and positive-cut filters">

<title>git_commit_graph_ext - Reachability index</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="git_commit_graph_ext - Reachability index">
<meta property="og:description" content="Describe different types of reachability indices (labels), define negative-cut and positive-cut filters">
<meta property="og:image" content="https://jnareb.github.io/git-commit-graph-ext/images/feline/FELINE_paper-fig_1-reachability_query_tradeoffs-zoom.png">
<meta property="og:site-name" content="git_commit_graph_ext">
<meta property="og:image:height" content="227">
<meta property="og:image:width" content="907">
<meta name="twitter:title" content="git_commit_graph_ext - Reachability index">
<meta name="twitter:description" content="Describe different types of reachability indices (labels), define negative-cut and positive-cut filters">
<meta name="twitter:image" content="https://jnareb.github.io/git-commit-graph-ext/images/feline/FELINE_paper-fig_1-reachability_query_tradeoffs-zoom.png">
<meta name="twitter:image-height" content="227">
<meta name="twitter:image-width" content="907">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">git_commit_graph_ext</span>
    </a>
  </div>
        <div class="quarto-navbar-tools ms-auto">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./reachability_index.html">Reachability index</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Commit graph labeling for speeding up Git commands</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./tools.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Graphs in Python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./related.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Related works: various reachability labelings</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./example_graphs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Example directed graphs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./reachability_index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Reachability index</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./levels.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Topological levels</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./interval_labels.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DFS Intervals Labelling</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./reach.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Reachability queries</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./git.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Extracting commit graphs from Git repositories</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./checkpoint.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Checkpointing</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./datasets.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Graph datasets</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./repos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Large Git repositories</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./evaluation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Reachability evaluation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./a.09_git_explore.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring extraction of commit graphs from Git repositories, and examining their shape and stats</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#label-only-and-labelgraph-approaches" id="toc-label-only-and-labelgraph-approaches" class="nav-link active" data-scroll-target="#label-only-and-labelgraph-approaches">Label-Only and Label+Graph approaches</a></li>
  <li><a href="#types-of-labels-in-augmented-online-search-algorithms-labelg" id="toc-types-of-labels-in-augmented-online-search-algorithms-labelg" class="nav-link" data-scroll-target="#types-of-labels-in-augmented-online-search-algorithms-labelg">Types of labels in augmented online search algorithms (Label+G)</a>
  <ul class="collapse">
  <li><a href="#negative-cut-filter" id="toc-negative-cut-filter" class="nav-link" data-scroll-target="#negative-cut-filter">Negative-cut filter</a></li>
  <li><a href="#positive-cut-filter" id="toc-positive-cut-filter" class="nav-link" data-scroll-target="#positive-cut-filter">Positive-cut filter</a></li>
  </ul></li>
  <li><a href="#git-specific-considerations" id="toc-git-specific-considerations" class="nav-link" data-scroll-target="#git-specific-considerations">Git-specific considerations</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/jnareb/git-commit-graph-ext/tree/master/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Reachability index</h1>
</div>

<div>
  <div class="description">
    Describe different types of reachability indices (labels), define negative-cut and positive-cut filters
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="label-only-and-labelgraph-approaches" class="level2">
<h2 class="anchored" data-anchor-id="label-only-and-labelgraph-approaches">Label-Only and Label+Graph approaches</h2>
<p><strong>Reachability query</strong> is one of the fundamental graph operations to answer whether a vertex (also called a node) can reach another vertex over a large directed graph. Usually directed acyclic graphs (DAGs) are considered, as reachability query in original graph can be answered by taking graph of <em>strongly connected components</em> (which is acyclic) and answering the translated query there.</p>
<p>Let <span class="math inline">\(G = (V,E)\)</span> be a directed graph, with <span class="math inline">\(V\)</span> being its set of vertices and <span class="math inline">\(E \subseteq V^2\)</span> its set of edges. A reachability query <span class="math inline">\(r(u, v)\)</span> asks whether a vertex <span class="math inline">\(v \in V\)</span> is reachable from a vertex <span class="math inline">\(u \in V\)</span>, i. e., whether there is a path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> in <span class="math inline">\(G\)</span>.</p>
<p>The main idea behind the various considered approaches in the literature is to compute a <strong>label</strong> for every vertex in a graph <span class="math inline">\(G\)</span>, by precomputing them offline. This is known as the <em>index construction</em> (there is constructed an <strong>index</strong> to maintain the mapping from vertices to labels). The index construction takes time, and storing the labels takes space.</p>
<p>The various methods to speed up reachability queries can be divided into two main categories (approaches), namely Label-Only and Label+G (or Label+Graph).</p>
<ul>
<li><p><strong>Label-Only</strong> approaches (as the name indicates) answer reachability queries using only the labels. Those have index size which is nonlinear function of the number of vertices (nodes), or have unbound index size.</p></li>
<li><p><strong>Label+Graph</strong> approaches use labels computed where possible, and conduct on-line search (be it depth-first search (DFS), breadth-first search (BFS), or bidirectional BFS) at run-time, if the reachability queries cannot be answered using the labels only. This class of methods is also called <em>Refined Online Search</em>.</p></li>
</ul>
<p>All the approaches take a different way to balance the three main costs, namely, - the index construction time, - the index size, and - the query time.</p>
<p><u>NOTE:</u> this is considered exploratory notebook, so the above text lack citations.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/feline/FELINE_paper-fig_1-reachability_query_tradeoffs-zoom.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Reachability query tradeoffs</figcaption>
</figure>
</div>
<p>The two basic approaches on extremes of a spectrum are shown on the figure above.</p>
<p>The first approach (left side) is to pre-compute and store the full transitive closure of edges, which allows constant time queries, but requires a quadratic space complexity, making it infeasible to maintain the index in the case of very large graphs. - index build time: <span class="math inline">\(\mathcal{O}(|V|*|E|)\)</span> - query answering time: <span class="math inline">\(\mathcal{O}(1)\)</span> (constant time) - index size: <span class="math inline">\(\mathcal{O}(|V|^2)\)</span> (quadratic memory size)</p>
<p>The second approach (right side) is to employ a DFS or BFS, or bidi-BFS search to verify the reachability, starting from vertex <span class="math inline">\(u\)</span> to vertex <span class="math inline">\(v\)</span>. This approach requires <span class="math inline">\(O(|V| + |E|)\)</span> time for each query, which is often unacceptable. - index build time: <span class="math inline">\(\mathcal{O}(1)\)</span> (no build time) - query answering time: <span class="math inline">\(\mathcal{O}(|V|+|E|)\)</span> - index size: <span class="math inline">\(\mathcal{O}(1)\)</span> (no additional memory needed)</p>
</section>
<section id="types-of-labels-in-augmented-online-search-algorithms-labelg" class="level2">
<h2 class="anchored" data-anchor-id="types-of-labels-in-augmented-online-search-algorithms-labelg">Types of labels in augmented online search algorithms (Label+G)</h2>
<p>In Label+Graph approach we conduct graph search if the reachability query cannot be answered using the labels only. In most methods those labels are then used to limit the search space (to augment the search to make if faster).</p>
<p>Two main types of labels are those that - exclude unreachable nodes, thus working as <strong>negative-cut filter</strong>, - find reachable nodes, thus working as <strong>positive-cut filter</strong></p>
<p>In this case, usually one can define <em>partial order</em> between given labels, that is for vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> we can have <span class="math inline">\(l(u) \preceq l(v)\)</span>, or <span class="math inline">\(l(u) \succeq l(v)\)</span>, or labels are incomparable (where <span class="math inline">\(l(u)\)</span> is the label for vertex <span class="math inline">\(u\)</span>).</p>
<section id="negative-cut-filter" class="level3">
<h3 class="anchored" data-anchor-id="negative-cut-filter">Negative-cut filter</h3>
<p>This type of filter (or reachability label) can be used to exclude unreachable nodes.</p>
<ul>
<li>for every <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, if <span class="math inline">\(u \neq v\)</span> and <span class="math inline">\(u\)</span> can reach <span class="math inline">\(v\)</span>, that is <span class="math inline">\(r(u,v)\)</span> holds, then we have <span class="math inline">\(l(u) \preceq l(v)\)</span></li>
<li>therefore if the condition <span class="math inline">\(l(u) \preceq l(v)\)</span> is not met, then <span class="math inline">\(u\)</span> cannot reach <span class="math inline">\(v\)</span> (there is no path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>)</li>
<li>the reverse is not always true; there can be <strong><em>false positives</em></strong></li>
</ul>
</section>
<section id="positive-cut-filter" class="level3">
<h3 class="anchored" data-anchor-id="positive-cut-filter">Positive-cut filter</h3>
<p>This type of filter (or reachability label) can be used to find when nodes are reachable one from the other</p>
<ul>
<li>if for <span class="math inline">\(u \neq v\)</span> we have <span class="math inline">\(l(u) \preceq l(v)\)</span>, then <span class="math inline">\(r(u,v)\)</span> is true, that is <span class="math inline">\(u\)</span> can reach <span class="math inline">\(v\)</span></li>
<li><span class="math inline">\(v\)</span> can be reachable from <span class="math inline">\(u\)</span> even if the condition is not met (<span class="math inline">\(l(u) \not\preceq l(v)\)</span>): <strong>false negative</strong></li>
</ul>
</section>
</section>
<section id="git-specific-considerations" class="level2">
<h2 class="anchored" data-anchor-id="git-specific-considerations">Git-specific considerations</h2>
<p>For reachability label to be considered for being added to Git (or more accurately to the <a href="https://git-scm.com/docs/commit-graph-format"><code>git commit-graph</code> file format</a> it must work for <strong>large graphs</strong>.</p>
<ul>
<li>Linux kernel: 826 000 commits (2019)</li>
<li>MS Windows: 3 100 000 commits (2019)</li>
<li>Android (AOSP): 874 000 commits (2019)</li>
<li>Chromium: 772 000 commits (2019)</li>
</ul>
<p>The commit graph (also known as revision graph) in version control systems is not static; it grows, but in very specific way. It grows by adding vertices (nodes), while <em>existing vertices are immutable</em> - with the sole exception that commits that are not reachable from one of the entry points (branches and tags) are removed during the garbage collection (<a href="https://git-scm.com/docs/git-gc">gc</a>) step.</p>
<p>There is no adding of edges (only as a byproduct of adding nodes), and no deletion of nodes.</p>
<p>Because the commit graph grows in size with time, we would like for reachability label to be able to be <strong>computed incrementally</strong>.</p>
<p>This could mean either that the reachability label is <strong>immutable</strong> itself, that is it would not change with the node-addition only growth of the graph. It could also mean that existing labels can be <strong>cheaply updated</strong> with the growth of the commit graph.</p>
<blockquote class="blockquote">
<p>TODO: the problem of layers of commit graph, see slides</p>
</blockquote>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>