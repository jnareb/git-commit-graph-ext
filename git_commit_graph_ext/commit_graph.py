# AUTOGENERATED! DO NOT EDIT! File to edit: 09_git.ipynb (unless otherwise specified).

__all__ = ['sparse_clone', 'get_repo', 'repo_generate_adjlist', 'repo_adjlist_to_graph', 'repo_to_graph',
           'commit_graph']

# Cell
# creating graphs in Python
import networkx as nx
# calling git commands
import subprocess
# checking for existence of paths, and manipulating paths
from pathlib import Path

# Cell
def sparse_clone(url, repo_name=None, repos_dir="repos"):
    """Clone Git repository by URL using sparse/partial clone

    The "Sparse Clone" or the "Partial Clone" feature is a performance
    optimization for Git that allows Git to function without having
    a complete copy of the repository.  The goal of this feature is to allow
    Git better handle extremely large repositories, or in this case store
    the repository using less disk space.

    To retrieve the commit graph out of the git repository only commit
    objects are needed, so all tree and blob objects can be omitted from the
    clone.

    Using sparse clone is much more efficient: the process is faster, and
    the resulting repository takes much less disk space than full clone.

    NOTE: Use of partial clone requires that the user be online and the origin
    remote or other promisor remotes be available for on-demand fetching
    of missing objects, unless the user can stay within the pre-selected
    subset of objects.

    see: https://git-scm.com/docs/git-clone
    see: https://git-scm.com/docs/git-rev-list#Documentation/git-rev-list.txt---filterltfilter-specgt
    see: https://github.com/git/git/blob/master/Documentation/technical/partial-clone.txt

    Parameters
    ----------
    url : str
        The repository to be cloned, in most cases it would be public URL
        that can be used to clone the remote repository.

    repo_name: str
        The name of a new directory to clone into. The "humanish" part of
        the source repository (of the `url` parameter) is used if no directory
        is explicitly given (`repo` for `/path/to/repo.git` and `foo` for
        `host.xz:foo/.git`).  Cloning into an existing directory is only
        allowed if the directory is empty.

    repos_dir : str
        The directory where to put cloned repository into.
        By default "repos" is used.
    """
    cmd = ['git']
    if repos_dir:
        cmd.extend(['-C', repos_dir])
    cmd.extend(['clone', '--mirror', '--filter=tree:0', '--quiet', url])
    if repo_name:
        cmd.append(repo_name)
    subprocess.run(cmd)

# Cell
def get_repo(url, repo_path, refresh=False):
    """Clone Git repository into given path, if needed

    If the path given by `repo_path` does not exist, or `refresh` is true,
    clone Git repository at `url` for later extraction of the commit graph.

    see: `sparse_clone()`

    Parameters
    ----------
    url : str
        The repository to be cloned, in most cases it would be public URL
        that can be used to clone the remote repository.

    repo_path: str
        The pathname under which one can find resulting Git repository.

    refresh: bool
        Whether to re-clone the repository if `repo_path` path exists.
        Default is false, to not perform a clone if not needed.
    """
    if refresh or not Path(repo_path).exists():
        sparse_clone(url, repo_name=repo_path, repos_dir="")

# Cell
def _repo_name_to_out_path(repo_path, out_dir="datasets"):
    """Create filename for storing adjacency list out of repository path

    This is a helper function used, among others, in `repo_generate_adjlist()`
    and `repo_adjlist_to_graph()`.

    Parameters
    ----------
    repo_path : str
        Path to the Git repository

    out_dir : str
        Directory where extracted commit graph data would be stored.
        Defaults to "datasets".

    Returns
    -------
    Path
        Path to the file storing the commit graph in the adjacency list
        file format.

        see: https://networkx.org/documentation/stable/reference/readwrite/adjlist.html
    """
    # The `out_dir` should not be None
    if out_dir is None:
        out_dir = "."
    # generate the name of the output file, as `pathlib.Path` object
    # removing the '*.git' extension / suffix from `repo_path`, if needed
    out_pathname = Path(out_dir) / (Path(repo_path).stem + "-commit_graph.adjlist.txt")

    return out_pathname


def repo_generate_adjlist(repo_path, out_dir="datasets", refresh=False):
    """Generate graph of revisions in the adjacency list format

    Can be read with `nx.read_adjlist()`; don't forget to ensure that
    NetworkX generates _directed_ graph.

    >>>> path = repo_generate_adjlist("repos/git.git")
    >>>> graph = nx.read_adjlist(path, create_using=nx.DiGraph)

    By default it does not recreate the file if it exists already,
    unless `refresh=True` argument is passed.

    Format
    ------
    The adjacency list format consists of lines with node labels.  The first
    label in a line is the source node. Further labels in the line are
    considered target nodes and are added to the graph along with an edge
    between the source node and target node.

    The graph with edges a-b, a-c, d-e can be represented as the following
    adjacency list (anything following the # in a line is a comment):

    > a b c # source target target
    > d e

    see: https://networkx.org/documentation/stable/reference/readwrite/adjlist.html

    Parameters
    ----------
    repo_path : str
        Path to the Git repository

    out_dir : str
        Directory where extracted commit graph data would be stored.
        Defaults to "datasets".

    refresh : bool
        Whether to regenerate the file with the commit graph in adjacency
        format if it exists.  Defaults to false.

    Returns
    -------
    Path
        Path where the commit graph in the adjacency file format
        can be found.
    """
    out_pathname = _repo_name_to_out_path(repo_path, out_dir=out_dir)
    # generate the adjacency list using git-log command; note: skip pull requests
    if refresh or not out_pathname.exists():
        with out_pathname.open("w") as outfile:
            subprocess.run(['git', '-C', repo_path,
                            'log', '--format=%h %p', '--topo-order', '--branches'],
                           stdout=outfile)
    return out_pathname

# Cell
def repo_adjlist_to_graph(repo_path, datasets_dir="datasets"):
    """Create `DiGraph` out of adjacency list file created from it

    NOTE: the `repo_to_graph()` function is safer to use, as it generates
    the graph of commits in the adjacency list file format of needed.

    Parameters
    ----------
    repo_path : str
        Path to the Git repository

    datasets_dir : str
        Directory where extracted commit graph data would be stored.
        Defaults to "datasets".

    Returns
    -------
    nx.DiGraph
        Directed graph of revisions as NetworkX's `DiGraph`
    """
    out_pathname = _repo_name_to_out_path(repo_path, out_dir=datasets_dir)
    return nx.read_adjlist(out_pathname, create_using=nx.DiGraph)

# Cell
def repo_to_graph(repo_path, datasets_dir="datasets", refresh=False):
    """Create a graph of commits for given local repository

    It uses existing file with the commit graph in the adjacency list file
    format, unless refresh is requested with `refresh=True`.  Automatically
    generates such file if it does not exist.

    Parameters
    ----------
    repo_path : str
        Path to the local Git repository

    datasets_dir : str
        Directory where extracted commit graph data can be stored, or will
        be stored.  Defaults to "datasets".

    refresh : bool
        Whether to regenerate the file with the commit graph in adjacency
        format if it exists.  Defaults to false.

    Returns
    -------
    nx.DiGraph
        Directed graph of revisions as NetworkX's `DiGraph`
    """
    out_pathname = repo_generate_adjlist(repo_path, out_dir=datasets_dir, refresh=refresh)
    return nx.read_adjlist(out_pathname, create_using=nx.DiGraph)


def commit_graph(url, repo_name,
                 repos_dir="repos", datasets_dir="datasets",
                 reclone=False, rescan=False):
    """Create a graph of commits for given remote repository, stored locally

    Given a Git repository `url`, clone it as `repo_name` in `repo_dir`
    directory, then create a graph of its commits as NetworkX `DiGraph`.

    Avoids re-cloning of the remote repository unless `reclone=True` is
    passed, and avoids rescanning the local copy of the repository if file
    in the adjacency list format with the commit graph information exists
    unless `rescan=True` is passed.

    Parameters
    ----------
    url : str
        The repository to be cloned, in most cases it would be public URL
        that can be used to clone the remote repository.

    repo_name: str
        The name of a new directory to clone into (or in other words name
        of local clone of the remote repository).

    repos_dir : str
        The directory where to put cloned repository into.
        By default "repos" is used.

    datasets_dir : str
        Directory where extracted commit graph data can be stored, or will
        be stored.  Defaults to "datasets".

    reclone : bool
        Whether to re-clone the repository if the local clone exists.
        Default is false, to not perform a clone if not needed.

    rescan : bool
        Whether to regenerate the file with the commit graph in adjacency
        format if it exists.  Defaults to false.

    Returns
    -------
    nx.DiGraph
        Directed graph of revisions as NetworkX's `DiGraph`
    """
    repo_path = Path(repos_dir) / repo_name
    get_repo(url, repo_path, refresh=reclone)
    graph = repo_to_graph(repo_path, datasets_dir=datasets_dir, refresh=rescan)
    graph.name = repo_name + ' commit graph'
    return graph