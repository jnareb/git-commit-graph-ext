# AUTOGENERATED! DO NOT EDIT! File to edit: 09_git.ipynb (unless otherwise specified).

__all__ = ['sparse_clone', 'get_repo', 'repo_generate_adjlist', 'repo_adjlist_to_graph', 'repo_to_graph',
           'commit_graph', 'graph_to_dataframe', 'dataframe_to_graph', 'save_graph_df', 'save_graph',
           'load_graph_df_from_file', 'load_graph_df', 'compute_reachability_labels', 'graph_data_to_dataframe']

# Cell
# creating graphs in Python
import networkx as nx
# calling git commands
import subprocess
# checking for existence of paths, and manipulating paths
from pathlib import Path
# data analysis and manipulation
import pandas as pd
# reachability labels
from .labelling.levels import find_levels
from .labelling.dfs_intervals import find_dfs_intervals, find_dfs_intervals_extra

# Cell
def sparse_clone(url, repo_name=None, repos_dir="repos"):
    """Clone Git repository by URL using sparse/partial clone

    The "Sparse Clone" or the "Partial Clone" feature is a performance
    optimization for Git that allows Git to function without having
    a complete copy of the repository.  The goal of this feature is to allow
    Git better handle extremely large repositories, or in this case store
    the repository using less disk space.

    To retrieve the commit graph out of the git repository only commit
    objects are needed, so all tree and blob objects can be omitted from the
    clone.

    Using sparse clone is much more efficient: the process is faster, and
    the resulting repository takes much less disk space than full clone.

    NOTE: Use of partial clone requires that the user be online and the origin
    remote or other promisor remotes be available for on-demand fetching
    of missing objects, unless the user can stay within the pre-selected
    subset of objects.

    see: https://git-scm.com/docs/git-clone
    see: https://git-scm.com/docs/git-rev-list#Documentation/git-rev-list.txt---filterltfilter-specgt
    see: https://github.com/git/git/blob/master/Documentation/technical/partial-clone.txt

    Parameters
    ----------
    url : str
        The repository to be cloned, in most cases it would be public URL
        that can be used to clone the remote repository.

    repo_name: str
        The name of a new directory to clone into. The "humanish" part of
        the source repository (of the `url` parameter) is used if no directory
        is explicitly given (`repo` for `/path/to/repo.git` and `foo` for
        `host.xz:foo/.git`).  Cloning into an existing directory is only
        allowed if the directory is empty.

    repos_dir : str
        The directory where to put cloned repository into.
        By default "repos" is used.
    """
    cmd = ['git']
    if repos_dir:
        cmd.extend(['-C', repos_dir])
    cmd.extend(['clone', '--mirror', '--filter=tree:0', '--quiet', url])
    if repo_name:
        cmd.append(repo_name)
    subprocess.run(cmd)

# Cell
def get_repo(url, repo_path, refresh=False):
    """Clone Git repository into given path, if needed

    If the path given by `repo_path` does not exist, or `refresh` is true,
    clone Git repository at `url` for later extraction of the commit graph.

    see: `sparse_clone()`

    Parameters
    ----------
    url : str
        The repository to be cloned, in most cases it would be public URL
        that can be used to clone the remote repository.

    repo_path: str
        The pathname under which one can find resulting Git repository.

    refresh: bool
        Whether to re-clone the repository if `repo_path` path exists.
        Default is false, to not perform a clone if not needed.
    """
    if refresh or not Path(repo_path).exists():
        sparse_clone(url, repo_name=repo_path, repos_dir="")

# Cell
def _repo_path_to_out_path(repo_path, out_dir="datasets"):
    """Create filename for storing adjacency list out of repository path

    This is a helper function used, among others, in `repo_generate_adjlist()`
    and `repo_adjlist_to_graph()`.

    Parameters
    ----------
    repo_path : str
        Path to the Git repository

    out_dir : str
        Directory where extracted commit graph data would be stored.
        Defaults to "datasets".

    Returns
    -------
    Path
        Path to the file storing the commit graph in the adjacency list
        file format.

        see: https://networkx.org/documentation/stable/reference/readwrite/adjlist.html
    """
    # The `out_dir` should not be None
    if out_dir is None:
        out_dir = "."
    # generate the name of the output file, as `pathlib.Path` object
    # removing the '*.git' extension / suffix from `repo_path`, if needed
    out_pathname = Path(out_dir) / (Path(repo_path).stem + "-commit_graph.adjlist.txt")

    return out_pathname


def repo_generate_adjlist(repo_path, out_dir="datasets", refresh=False):
    """Generate graph of revisions in the adjacency list format

    Can be read with `nx.read_adjlist()`; don't forget to ensure that
    NetworkX generates _directed_ graph.

    >>>> path = repo_generate_adjlist("repos/git.git")
    >>>> graph = nx.read_adjlist(path, create_using=nx.DiGraph)

    By default it does not recreate the file if it exists already,
    unless `refresh=True` argument is passed.

    Format
    ------
    The adjacency list format consists of lines with node labels.  The first
    label in a line is the source node. Further labels in the line are
    considered target nodes and are added to the graph along with an edge
    between the source node and target node.

    The graph with edges a-b, a-c, d-e can be represented as the following
    adjacency list (anything following the # in a line is a comment):

    > a b c # source target target
    > d e

    see: https://networkx.org/documentation/stable/reference/readwrite/adjlist.html

    Parameters
    ----------
    repo_path : str
        Path to the Git repository

    out_dir : str
        Directory where extracted commit graph data would be stored.
        Defaults to "datasets".

    refresh : bool
        Whether to regenerate the file with the commit graph in adjacency
        format if it exists.  Defaults to false.

    Returns
    -------
    Path
        Path where the commit graph in the adjacency file format
        can be found.
    """
    out_pathname = _repo_path_to_out_path(repo_path, out_dir=out_dir)
    # generate the adjacency list using git-log command; note: skip pull requests
    if refresh or not out_pathname.exists():
        with out_pathname.open("w") as outfile:
            subprocess.run(['git', '-C', repo_path,
                            'log', '--format=%h %p', '--topo-order', '--branches'],
                           stdout=outfile)
    return out_pathname

# Cell
def repo_adjlist_to_graph(repo_path, datasets_dir="datasets"):
    """Create `DiGraph` out of adjacency list file created from it

    NOTE: the `repo_to_graph()` function is safer to use, as it generates
    the graph of commits in the adjacency list file format of needed.

    Parameters
    ----------
    repo_path : str
        Path to the Git repository

    datasets_dir : str
        Directory where extracted commit graph data would be stored.
        Defaults to "datasets".

    Returns
    -------
    nx.DiGraph
        Directed graph of revisions as NetworkX's `DiGraph`
    """
    out_pathname = _repo_path_to_out_path(repo_path, out_dir=datasets_dir)
    return nx.read_adjlist(out_pathname, create_using=nx.DiGraph)

# Cell
def repo_to_graph(repo_path, datasets_dir="datasets", refresh=False):
    """Create a graph of commits for given local repository

    It uses existing file with the commit graph in the adjacency list file
    format, unless refresh is requested with `refresh=True`.  Automatically
    generates such file if it does not exist.

    Parameters
    ----------
    repo_path : str
        Path to the local Git repository

    datasets_dir : str
        Directory where extracted commit graph data can be stored, or will
        be stored.  Defaults to "datasets".

    refresh : bool
        Whether to regenerate the file with the commit graph in adjacency
        format if it exists.  Defaults to false.

    Returns
    -------
    nx.DiGraph
        Directed graph of revisions as NetworkX's `DiGraph`
    """
    out_pathname = repo_generate_adjlist(repo_path, out_dir=datasets_dir, refresh=refresh)
    return nx.read_adjlist(out_pathname, create_using=nx.DiGraph)


def commit_graph(url, repo_name,
                 repos_dir="repos", datasets_dir="datasets",
                 reclone=False, rescan=False):
    """Create a graph of commits for given remote repository, stored locally

    Given a Git repository `url`, clone it as `repo_name` in `repo_dir`
    directory, then create a graph of its commits as NetworkX `DiGraph`.

    Avoids re-cloning of the remote repository unless `reclone=True` is
    passed, and avoids rescanning the local copy of the repository if file
    in the adjacency list format with the commit graph information exists
    unless `rescan=True` is passed.

    Parameters
    ----------
    url : str
        The repository to be cloned, in most cases it would be public URL
        that can be used to clone the remote repository.

    repo_name: str
        The name of a new directory to clone into (or in other words name
        of local clone of the remote repository).

    repos_dir : str
        The directory where to put cloned repository into.
        By default "repos" is used.

    datasets_dir : str
        Directory where extracted commit graph data can be stored, or will
        be stored.  Defaults to "datasets".

    reclone : bool
        Whether to re-clone the repository if the local clone exists.
        Default is false, to not perform a clone if not needed.

    rescan : bool
        Whether to regenerate the file with the commit graph in adjacency
        format if it exists.  Defaults to false.

    Returns
    -------
    nx.DiGraph
        Directed graph of revisions as NetworkX's `DiGraph`
    """
    repo_path = Path(repos_dir) / repo_name
    get_repo(url, repo_path, refresh=reclone)
    graph = repo_to_graph(repo_path, datasets_dir=datasets_dir, refresh=rescan)
    graph.name = repo_name
    return graph

# Cell
def _repo_basename(repo_path):
    """Create name of repository out of its pathname

    This is a helper function used, among others, in ...

    Examples:
    ---------
    >>>> _repo_basename('hellogitworld')
    'hellogitworld'
    >>>> _repo_basename('repos/hellogitworld.git')
    'hellogitworld'

    Parameters
    ----------
    repo_path : str
        Path to the Git repository, for example 'hellogitworld',
        or 'hellogitworld.git', or 'repos/hellogitworld.git', or 'repos/hellogitworld/.git'
        for Git repository cloned from <https://github.com/githubtraining/hellogitworld>

    Returns
    -------
    str
        The name of repository, to be later used as a base for commit graph name,
        and the pathname of a file where to save information about thw history
        structure of the repository.
    """
    # generate the name of the output file, as `pathlib.Path` object
    # removing the '*.git' extension / suffix from `repo_path`, if needed
    out_pathname = Path(repo_name).stem

    # convert it to string
    return str(out_pathname)


def _commit_graph_name(repo_name):
    """Create the name of a commit graph out of repository name.

    This is a helper function used, among others, in ...

    Examples:
    ---------
    >>>> _commit_graph_name('hellogitworld')
    'hellogitworld-commit_graph'

    Parameters
    ----------
    repo_name : str
        The name of the repository, for example the result of calling the
        `_repo_basename()` function.

    Returns
    -------
    str
        The name of the commit graph of the repository, to be used as a base
        for the pathname of a file where to save information about the history
        structure of the repository.
    """
    return repo_name + '-commit_graph'


def _repo_graph_name(repo_path):
    """Create the name of a commit graph out of repository path (its pathname)

    This is a helper function used, among others, in ...

    Examples:
    ---------
    >>>> _repo_graph_name('repos/hellogitworld.git')
    'hellogitworld-commit_graph'

    Parameters
    ----------
    repo_path : str
        Path to the Git repository (`<graph>.name` can be used), for example
        'hellogitworld', or 'hellogitworld.git', or 'repos/hellogitworld.git',
        or 'repos/hellogitworld/.git' for Git repository cloned from
        <https://github.com/githubtraining/hellogitworld>

    Returns
    -------
    str
        The name of the commit graph of the repository, to be used as a base
        for the pathname of a file where to save information about the history
        structure of the repository.
    """
    return _commit_graph_name(_repo_basename(repo_path))



# Cell
def _savefile_name(graph_name, out_dir='datasets', kind='df_edgelist', file_format='csv.gz'):
    """Create filename for storing graph structure and other graph data

    This is a helper function used, among others, in ...

    Examples:
    ---------
    >>>> _savefile_name('example_graph')
    Path('datasets/example_graph.df_edgelist.csv.gz')

    Parameters
    ----------
    graph_name : str
        Name of the graph (`<graph>.name` can be used).

    out_dir : str
        Directory where saved commit graph data would be stored.
        Defaults to "datasets".

    kind : str
        What type of data is stored in a file, and in what representation.
        The default value is 'df_edgelist', used to store graph structure in
        the edge list format in a `pandas.DataFrame`.

    file_format : str
        Format of a file, for example how the `DataFrame` is saved.
        Defaults to 'csv.gz' (gzip-compressed Comma Separated Values).

    Returns
    -------
    Path
        Path to the file storing the graph structure or graph data in
        the appropriate representation and appropriate file format.
    """
    # The `out_dir` should not be None
    if out_dir is None:
        out_dir = "."

    # compose the basename of the pathname
    filename = graph_name
    # TODO: there would special case for saving to HDF5 files, which can
    # store multiple data in a single file, so there would be no need
    # to add <kind> to basename of such output file
    if kind is not None and kind != '':
        filename += '.' + kind
    if file_format is not None and file_format != '':
        filename += '.' + file_format
    # generate the name of the output file, as `pathlib.Path` object
    return Path(out_dir) / filename


def _out_basename(graph_name, out_dir='datasets'):
    return _savefile_name(graph_name, out_dir=out_dir, kind=None, file_format=None)


def _repo_graph_savefile(repo_path, out_dir='datasets'):
    """Create filename for storing adjacency list out of repository path

    This is a helper function used, among others, in ...

    Examples:
    ---------
    >>>> _repo_graph_savefile('repos/hellogitworld.git')
    Path('datasets/hellogitworld-commit_graph.adjlist.txt')
    >>>> _repo_graph_savefile('repos/hellogitworld.git', out_dir='data')
    Path('data/hellogitworld-commit_graph.adjlist.txt')

    Parameters
    ----------
    repo_path : str
        Path to the Git repository, for example 'hellogitworld',
        or 'hellogitworld.git', or 'repos/hellogitworld.git', or 'repos/hellogitworld/.git'
        for Git repository cloned from <https://github.com/githubtraining/hellogitworld>

    out_dir : str
        Directory where extracted commit graph data would be stored.
        Defaults to "datasets".

    Returns
    -------
    Path
        Path to the file storing the commit graph in the adjacency list
        file format.

        see: https://networkx.org/documentation/stable/reference/readwrite/adjlist.html
    """
    graph_name = _repo_graph_name(repo_path)
    return _savefile_name(graph_name, out_dir=out_dir, kind='adjlist', file_format='txt')

# Cell
def graph_to_dataframe(graph):
    return nx.to_pandas_edgelist(graph)


def dataframe_to_graph(df):
    return nx.from_pandas_edgelist(df, create_using=nx.DiGraph)



# Cell
def save_graph_df(df, graph_name, datasets_dir='datasets', output_format='csv.gz', overwrite=False):
    filename = _savefile_name(graph_name, out_dir=datasets_dir,
                              kind='df_edgelist', file_format=output_format)
    print('-> filename:', filename)
    if not overwrite and Path(filename).is_file():
        return
    if output_format == 'csv' or output_format == 'csv.gz':
        df.to_csv(filename)
    else:
        raise NotImplementedError("Writing to '{}' format is not supported".format(output_format))


def save_graph(graph, graph_name=None, datasets_dir='datasets', output_format='csv.gz', overwrite=False):
    df = graph_to_dataframe(graph)
    # if `graph_name` is not given, check the `name` attribute of the `graph`
    if graph_name is None:
        # NOTE: "'name' in graph" checks if there is node named 'name' in the graph
        if hasattr(graph, 'name'):
            graph_name = graph.name
        else:
            raise RuntimeError("Neither 'graph_name' parameter given, nor 'graph' has 'name' attribute")

    print('-> graph_name:', graph_name)
    save_graph_df(df, graph_name,
                  datasets_dir=datasets_dir, output_format=output_format, overwrite=overwrite)


def load_graph_df_from_file(filename, input_format='csv.gz'):
    if input_format == 'csv' or input_format == 'csv.gz':
        return pd.read_csv(filename, index_col=0)
    else:
        raise NotImplementedError("Reading from '{}' format is not supported".format(input_format))


def load_graph_df(graph_name, datasets_dir='datasets', input_format='csv.gz'):
    filename = _savefile_name(graph_name, out_dir=datasets_dir,
                              kind='df_edgelist', file_format=input_format)
    print('<- filename:', filename)
    return load_graph_df_from_file(filename, input_format=input_format)



# Cell
def compute_reachability_labels(graph, recompute=False):
    if recompute or not hasattr(graph, 'lvl'):
        graph.lvl = find_levels(graph)
    if recompute or not hasattr(graph, 'mpi_ext'):
        graph.mpi_ext = find_dfs_intervals_extra(graph)
    return graph



# Cell
def graph_data_to_dataframe(graph, append_to=None):
    compute_reachability_labels(graph)

    # create the DataFrame and name its index
    df = pd.DataFrame.from_dict(graph.mpi_ext, orient='index', columns=['f_min', 'min', 'post'])
    df.index.name = 'node'
    # add other reachability labels
    df['level'] = pd.Series(graph.lvl)
    # add and compute other data
    df['in degree'] = pd.Series(dict(graph.in_degree()))
    df['out degree'] = pd.Series(dict(graph.out_degree()))
    df['degree'] = df['in degree'] + df['out degree']

    # append if needed
    if append_to:
        df = pd.concat([append_to, df], axis=1, join='inner')

    return df

