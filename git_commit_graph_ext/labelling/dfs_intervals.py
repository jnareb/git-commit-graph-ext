# AUTOGENERATED! DO NOT EDIT! File to edit: 07_interval_labels.ipynb (unless otherwise specified).

__all__ = ['find_dfs_spanning', 'find_dfs_intervals']

# Cell
import networkx as nx
from copy import deepcopy


# Cell
def find_dfs_spanning(G):
  """Find edges of the DFS spanning tree for graph G

  This is used to visualize the spanning tree (spanning forest,
  tree cover) in example small graphs.  This function is also used
  to compute DFS intervals, among others in `find_dfs_intervals()`

  Parameters
  ----------
  G : NetworkX graph
      Graph to find spanning-tree in.

  Returns
  -------
  edges : list
      A list of edges in the depth-first-search.

  Examples
  --------
  >>> G = nx.path_graph(5)
  >>> find_dfs_spanning(G)
  [(0, 1), (1, 2), (2, 3), (3, 4)]

  Notes
  -----
  The source is chosen arbitrarily and repeatedly until all
  components in the graph are searched.
  """
  # this may not cover all nodes
  return list(nx.dfs_edges(G))

# Cell
def find_dfs_intervals(DG, attr=None):
  """Find min-post labeling of all vertices in graph G, using DFS spanning-tree

  Min-post interval labeling strategy labels each node 'u' in the directed
  spanning tree (DFS tree here) of the acyclic graph `DG` with a range
  I_u = [s_u, e_u], where e_u denotes the rank of the node 'u' in post-order
  traversal of the tree (ranks assumed to begin at 1), and s_u denotes the
  lowest rank of any node 'w' in the subtree rooted at 'u' (including 'u').

  Parameters:
  -----------
  DG : NetworkX DiGraph
      Directed acyclic graph.

  attr : str, optional (default=None)
      If set, name of a node attribute under which store min-post intervals.

  Returns:
  --------
  dict of two-element lists of ints
      Dictionary, where keys are node indices, and values are two element
      lists storing min-post interval (of integers)
  """
  ivl = {}
  # create graph of spanning tree (DFS spanning tree) of DG
  span=nx.DiGraph()
  span.add_nodes_from(DG)
  span.add_edges_from(find_dfs_spanning(DG))
  # DEBUG
  #print('span=%r' % find_dfs_spanning(DG))

  # any post-order ordering would be good
  nodelist = nx.dfs_postorder_nodes(DG)
  for pos, node in enumerate(nodelist, start=1):
    ivl[node] = [pos, pos]
    if span.out_degree(node) > 0:
      ivl[node][0] = min(pos,
                         *[ivl[neigh][0]
                           for neigh in span.successors(node)])
    # DEBUG
    #print('node=%s [%d,%d] -> %r' %
    #      (node, ivl[node][0],ivl[node][1],list(span.successors(node))))

  if attr is not None:
    for node, interval in ivl.items():
      DG.nodes[node][attr] = deepcopy(interval)

  return ivl