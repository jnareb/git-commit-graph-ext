# AUTOGENERATED! DO NOT EDIT! File to edit: ../../07_interval_labels.ipynb.

# %% auto 0
__all__ = ['find_dfs_spanning', 'find_dfs_intervals', 'find_dfs_intervals_extra']

# %% ../../07_interval_labels.ipynb 4
import networkx as nx
from copy import deepcopy

# %% ../../07_interval_labels.ipynb 63
def find_dfs_spanning(G):
  """Find edges of the DFS spanning tree for graph G

  This is used to visualize the spanning tree (spanning forest,
  tree cover) in example small graphs.  This function is also used
  to compute DFS intervals, among others in `find_dfs_intervals()`

  Parameters
  ----------
  G : NetworkX graph
      Graph to find spanning-tree in.

  Returns
  -------
  edges : list
      A list of edges in the depth-first-search.

  Examples
  --------
  >>> G = nx.path_graph(5)
  >>> find_dfs_spanning(G)
  [(0, 1), (1, 2), (2, 3), (3, 4)]

  Notes
  -----
  The source is chosen arbitrarily and repeatedly until all
  components in the graph are searched.
  """
  # this may not cover all nodes
  return list(nx.dfs_edges(G))

# %% ../../07_interval_labels.ipynb 77
def find_dfs_intervals(DG, attr=None):
  """Find min-post labeling of all vertices in graph G, using DFS spanning-tree

  Min-post interval labeling strategy labels each node 'u' in the directed
  spanning tree (DFS tree here) of the acyclic graph `DG` with a range
  I_u = [s_u, e_u], where e_u denotes the rank of the node 'u' in post-order
  traversal of the tree (ranks assumed to begin at 1), and s_u denotes the
  lowest rank of any node 'w' in the subtree rooted at 'u' (including 'u').

  Parameters:
  -----------
  DG : NetworkX DiGraph
      Directed acyclic graph.

  attr : str, optional (default=None)
      If set, name of a node attribute under which store min-post intervals.

  Returns:
  --------
  dict of two-element lists of ints
      Dictionary, where keys are node indices, and values are two element
      lists storing min-post interval (of integers)
  """
  ivl = {}
  # create graph of spanning tree (DFS spanning tree) of DG
  span=nx.DiGraph()
  span.add_nodes_from(DG)
  span.add_edges_from(find_dfs_spanning(DG))
  # DEBUG
  #print('span=%r' % find_dfs_spanning(DG))

  # any post-order ordering would be good
  nodelist = nx.dfs_postorder_nodes(DG)
  for pos, node in enumerate(nodelist, start=1):
    ivl[node] = [pos, pos]
    if span.out_degree(node) > 0:
      ivl[node][0] = min(pos,
                         *[ivl[neigh][0]
                           for neigh in span.successors(node)])
    # DEBUG
    #print('node=%s [%d,%d] -> %r' %
    #      (node, ivl[node][0],ivl[node][1],list(span.successors(node))))

  if attr is not None:
    for node, interval in ivl.items():
      DG.nodes[node][attr] = deepcopy(interval)

  return ivl

# %% ../../07_interval_labels.ipynb 86
def find_dfs_intervals_extra(DG, extra=False):
    """Find DFS-derived data of all vertices in graph G

    Min-post interval labeling strategy labels each node 'u' in the directed
    spanning tree (DFS tree here) of the acyclic graph `DG` with a range
    I_u = [s_u, e_u], where e_u denotes the rank of the node 'u' in post-order
    traversal of the tree (ranks assumed to begin at 1), and s_u denotes the
    lowest rank of any node 'w' in the subtree rooted at 'u' (including 'u').
    This interval is stored under 'min' and 'post' keys in returned dict.

    For depth first-search (DFS) all nodes reachable from node 'u' have their
    topological ordering in DFS tree, i.e. 'post', smaller than the 'post'
    value for 'u'.  Additionally we can define 'f_min' as minimum 'post'
    number for each node reachable from 'u', and 'f_gap' as maximum 'post'
    number of nodes reachable from 'u' that are not in DFS subtree rooted
    at 'u' or None if 'f_gap' would be equal to 'u' node's 'min' number.

    We can also define 'p_tree' to be node reachable from 'u', but not in
    subtree rooted at 'u', that ('p_tree') has largest subtree.  If such
    node does not exist it is set to None.  For DFS spanning tree we can
    calculate this value effectively.

    This is based on *modified* algorithms from PReaCH paper [1];
    note that the original version in the paper [1] uses
    preorder not postorder numbers (pre-max not min-post).

    References:
    -----------
    [1] Florian Merz, Peter Sanders "PReaCH: A Fast Lightweight
        Reachability Index using Pruning and Contraction Hierarchies" (2014)
        In: Schulz A.S., Wagner D. (eds) Algorithms - ESA 2014. ESA 2014.
        Lecture Notes in Computer Science, vol 8737. Springer, Berlin,
        Heidelberg (Conference Paper: European Symposium on Algorithms)
        https://doi.org/10.1007/978-3-662-44777-2_58
        http://arxiv.org/abs/1404.4465

    Parameters:
    -----------
    DG : NetworkX DiGraph
        Directed acyclic graph.

    extra : bool, optional (default=False)
        Whether to compute extra DFS data in addition to min-post interval.

    Returns:
    --------
    dict of dicts
        Dictionary, where keys are node indices, and values are dictionaries
        with various DFS spanning-tree derived data.
    """
    data = {}
    # create graph of spanning tree (DFS spanning tree) of DG
    span = nx.DiGraph()
    span.add_nodes_from(DG)
    span.add_edges_from(find_dfs_spanning(DG))

    # needs depth-first search for some of indices to actually work
    nodelist = nx.dfs_postorder_nodes(DG)
    for pos, node in enumerate(nodelist, start=1):
        data[node] = {}

        # DEBUG
        # print('node=%s\n -> %r\n => %r' %
        #      (node,
        #       list(span.successors(node)),
        #       list(DG.successors(node))))

        data[node]['post'] = pos
        if span.out_degree(node) == 0:
            data[node]['min'] = pos
        else:
            data[node]['min'] = min(pos,
                                    *[data[neigh]['min']
                                      for neigh in span.successors(node)])

        # print("data[%s]: %r" % (node, data[node]))

        # min-post graph interval (min over whole graph)
        if DG.out_degree(node) == 0:
            data[node]['f_min'] = pos
        else:
            data[node]['f_min'] = min(pos,
                                      *[data[neigh]['f_min']
                                        for neigh in DG.successors(node)])

        # PReaCH specific extensions
        if not extra:
            continue

        if DG.out_degree(node) == 0:
            data[node]['f_gap'] = None
            data[node]['p_tree'] = None
        else:
            f_gap_candidates = \
                [data[neigh]['post']
                 for neigh in DG.successors(node)
                 if data[neigh]['post'] < data[node]['min']] + \
                [data[neigh]['f_gap']
                 for neigh in DG.successors(node)
                 if data[neigh]['f_gap'] is not None]
            if f_gap_candidates:
                data[node]['f_gap'] = max(f_gap_candidates)
            else:
                data[node]['f_gap'] = None
            # print("f_gap[%s]: %r" % (node, data[node]['f_gap']))

            # print("p_tree: %r (candidates, part 1)" %
            #      [data[neigh]['p_tree']
            #       for neigh in DG.successors(node)])
            p_tree_candidates = \
                [data[neigh]['p_tree']
                 for neigh in DG.successors(node)
                 if data[neigh]['p_tree'] is not None and
                    data[neigh]['post'] < data[node]['min']] + \
                [neigh
                 for neigh in DG.successors(node)
                 if data[neigh]['post'] < data[node]['min']]
            if p_tree_candidates:
                data[node]['p_tree'] = max(
                    p_tree_candidates,
                    key=lambda n: data[n]['post'] - data[n]['min']
                )
                # print("p_tree[%s]: %r" % (node, data[node]['p_tree']))
            else:
                data[node]['p_tree'] = None

        # print("\n")

    return data
